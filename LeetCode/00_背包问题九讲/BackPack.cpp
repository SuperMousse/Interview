
***************************** 第一讲 01背包问题 ***************************************** 
*************************************************************************************** 
有N 件物品和一个容量为V 的背包。放入第i 件物品耗费的费用是Ci，得到的价值是Wi。求解将哪些物品装入背包可使价值总和
最大。

假设山洞里共有a,b,c,d ,e这5件宝物（不是5种宝物），它们的重量分别是2,2,6,5,4，
它们的价值分别是6,3,5,4,6，现在给你个承重为10的背包, 怎么装背包，可以才能带走最多的财富(每件宝物不可重复选取)。

i  name weight value | j: 1   2   3   4   5   6   7   8   9   10
1   a     4     6    |    0   0   0   6   6   6   6   6   6   6
2   b     5     4    |    0   0   0   6   6   6   6   6   10  10
3   c     6     5    |    0   0   0   6   6   6   6   6   10  11
4   d     2     3    |    0   3 	3   6 	6   9 	9  	9 	10 	11
5   e     2     6    |    0   6 	6   9 	9   12  12 	15 	15 	15

// ************************ 二维动态规划 ************************
// f[i, j]表示到第i个宝物为止, 使用j大小的背包所获得的财富
for i in [1, 5]:
  for j in [W_i, 10]:
    // j in [1, 10] and j-W_i >= 0
    f[i, j] = max(f[i-1, j], f[i-1, j-W_i]+V_i)
    
这里需要注意: w_i表示的是第i个物品, 对于编程时的第i个物品, 其索引事实上为i-1, 所以是j-W_{i-1}

f[1, 4]  = max(f[0, 4], f[0, 0]+V_1) = max(0, 0+6) = 6
f[1, 5]  = max(f[0, 5], f[0, 1]+V_1) = max(0, 0+6) = 6
f[1, 6]  = max(f[0, 6], f[0, 2]+V_1) = max(0, 0+6) = 6
f[1, 7]  = max(f[0, 7], f[0, 3]+V_1) = max(0, 0+6) = 6
f[1, 8]  = max(f[0, 8], f[0, 4]+V_1) = max(0, 0+6) = 6
f[1, 9]  = max(f[0, 9], f[0, 5]+V_1) = max(0, 0+6) = 6
f[1, 10] = max(f[0, 10], f[0, 6]+V_1) = max(0, 0+6) = 6

f[2, 5]  = max(f[1, 5], f[1, 0]+V_2) = max(6, 0+4) = 6
f[2, 6]  = max(f[1, 6], f[1, 1]+V_2) = max(6, 0+4) = 6
f[2, 7]  = max(f[1, 7], f[1, 2]+V_2) = max(6, 0+4) = 6
f[2, 8]  = max(f[1, 8], f[1, 3]+V_2) = max(6, 0+4) = 6
f[2, 9]  = max(f[1, 9], f[1, 4]+V_2) = max(6, 6+4) = 10
f[2, 10] = max(f[1, 10], f[1, 5]+V_2) = max(6, 6+4) = 10


f[3, 6]  = max(f[2, 6], f[2, 0]+V_3) = max(6, 0+5) = 6
f[3, 7]  = max(f[2, 7], f[2, 1]+V_3) = max(6, 0+5) = 6
f[3, 8]  = max(f[2, 8], f[2, 2]+V_3) = max(6, 0+5) = 6
f[3, 9]  = max(f[2, 9], f[2, 3]+V_3) = max(10, 0+5) = 6
f[3, 10] = max(f[2, 10], f[2, 4]+V_3) = max(10, 0+5) = 6 // 此时发现f[2, 4]并未进行计算,因此需要把f[2, 4]从f[1, 4]继承下来

伪代码修正如下:
for i in [1, 5]:
  for j in [1, 10]:
    if j-W_i >= 0:
      f[i, j] = max(f[i-1, j], f[i-1, j-W_i]+V_i)
    else:
      f[i, j] = f[i-1, j]
      
int dp(int num, int volume, vector<int> weight, vector<int> value) {
    if ((weight.size() != value.size()) || num <= 0 || volume <= 0) {
        return 0;
    }
    vector<vector<int>> dp(num+1, vector<int>(volume+1, 0));
    for (int i = 1; i <= num; ++i) {
        for (int j = 1; j <= volume; ++j) {
            if ((j - weight[i-1]) >= 0) {
                dp[i][j] = max(dp[i-1][j], dp[i-1][j-weight[i-1]] + value[i-1]);
            }
            else {
                dp[i][j] = dp[i-1][j];
            }
        }
    }
    cout << dp[num][volume] << endl;
    return dp[num][volume];
}
      
// ************************ 一维动态规划 ************************
   f[i, j] = max(f[i-1, j], f[i-1, j-W_i]+V_i) 
=> f[j] = max(f[j], f[j-W_i]+V_i)

若不对j的循环顺序进行更改:
for i in [1, 5]:
  for j in [1, 10]:
    f[j] = max(f[j], f[j-W_i]+V_i)
    
f[1, 4]  = max(f[0, 4], f[0, 0]+V_1) = max(0, 0+6) = 6
f[1, 5]  = max(f[0, 5], f[0, 1]+V_1) = max(0, 0+6) = 6
f[1, 6]  = max(f[0, 6], f[0, 2]+V_1) = max(0, 0+6) = 6
f[1, 7]  = max(f[0, 7], f[0, 3]+V_1) = max(0, 0+6) = 6
f[1, 8]  = max(f[0, 8], f[0, 4]+V_1) = max(0, 0+6) = 6
f[1, 9]  = max(f[0, 9], f[0, 5]+V_1) = max(0, 0+6) = 6
f[1, 10] = max(f[0, 10], f[0, 6]+V_1) = max(0, 0+6) = 6

若正向更新, 会发现f[8]其实要使用f[0, 4]但是f[4]已经提前被更新成f[1, 4]了, 无法使用i-1的数据

所以将j进行逆序处理
for i in [1, 5]:
  for j in [10, 1]:
    f[j] = max(f[j], f[j-W_i]+V_i)
    
f[1, 10] = max(f[0, 10], f[0, 6]+V_1) = max(0, 0+6) = 6
f[1, 9]  = max(f[0, 9], f[0, 5]+V_1) = max(0, 0+6) = 6
f[1, 8]  = max(f[0, 8], f[0, 4]+V_1) = max(0, 0+6) = 6
f[1, 7]  = max(f[0, 7], f[0, 3]+V_1) = max(0, 0+6) = 6
f[1, 6]  = max(f[0, 6], f[0, 2]+V_1) = max(0, 0+6) = 6
f[1, 5]  = max(f[0, 5], f[0, 1]+V_1) = max(0, 0+6) = 6
f[1, 4]  = max(f[0, 4], f[0, 0]+V_1) = max(0, 0+6) = 6

此时发现, f[8]先使用了f[0, 4]然后f[1, 4]才进行更新

// 初始化细节
// 若恰好装满背包: 则f[0] = 0, f[1]...f[10]应该为-inf
// 若可以不装满背包: 则f[0]~f[10]均为0
// 因为初始化表示了没有任何物品放置时, 数组的合法状态
// 若必须装满背包, 则只有容量为0的背包的合理value为0, 其余状态没有合法解, 属于未定义
// 若不必装满背包, 则任何容量的背包都有合法解0, 因为可以不选取任何物品

// 常数优化
for i in [1, N]:
  for j in [V, W_i]:
    f[j] = max(f[j], f[j-W_i]+V_i)
中的j循环可以从 j \in [V, W_i] 优化为 j \in [V, max(W_i, V-\sum_{k=i}^{N}W_k)],
\sum_{k=i}^{N}W_k 表示i到N的所有物品重量

------------------------------------------------------>
       (V-\sum<=C_i)          C_i      (V-\sum>C_i)
考虑到我们只需要矩阵的右下角的元素, 我们只需要考虑计算右下角的元素需要的最少dp数即可, 
对于i = N时的右下角元素f[V], 有如下等式成立
f[V] = max(f[V], f[V-W_N]+V_N), 需要使用f[V-W_N]元素
对于i = N-1层的f[V-W_N], 有
f[V-W_N] = max(f[V-W_N], f[V-W_N-W_N-1]+V_N),
依次递推可知, 对于第i层实际上需要计算的可以到达网络右下角的元素应该为V - W_N - W_n-1 - ... - W_i

因此, 对于第i层, 小于W_i由于背包容量不足不更新, 小于V - W_N - W_n-1 - ... - W_i由于无法到达右下角不需要更新, 取二者Max即可


                              
i  name weight value | j: 1   2   3   4   5   6   7   
                          0   0   0   0   0   0   0  
1   a     1     6    |    *   *   6   6   6   6   6   
2   b     1     4    |    *   *   *   10  10  10  10   
3   c     1     5    |    *   *   *   *   15  15  15   
4   d     1     3    |    *   * 	*   * 	*   18 	18  	
5   e     1     6    |    *   * 	*   * 	*   *   12 	

for i in [1, N]:
  for j in [V, max(W_i, V-\sum_{k=i}^{N}W_k)]:
    f[j] = max(f[j], f[j-W_i]+V_i)

i = 1
max(W_i, V-\sum_{k=i}^{N}W_k)) = max(1, 7-4) = 3
f[7] = max(f[7], f[6]+V_1) = max(0, 0+6) = 6
f[6] = max(f[6], f[5]+V_1) = max(0, 0+6) = 6
f[5] = max(f[5], f[4]+V_1) = max(0, 0+6) = 6
f[4] = max(f[4], f[3]+V_1) = max(0, 0+6) = 6
f[3] = max(f[3], f[2]+V_1) = max(0, 0+6) = 6
f[1]在正常算法中应该更新, 此时省去

i = 2
max(W_i, V-\sum_{k=i}^{N}W_k)) = max(1, 7-3) = 4
f[7] = max(f[7], f[6]+V_2) = max(6, 6+4) = 10
f[6] = max(f[6], f[5]+V_2) = max(6, 6+4) = 10
f[5] = max(f[5], f[4]+V_2) = max(6, 6+4) = 10
f[4] = max(f[4], f[3]+V_2) = max(6, 6+4) = 10
f[3], f[2], f[1]在正常算法中应该更新, 此时省去


***************************** 第二讲 完全背包问题 ***************************************** 
*************************************************************************************** 
有N 种物品和一个容量为V 的背包，每种物品都有无限件可用。放入第i 种物品的费用是Ci，价值是Wi。求解：将哪些物品
装入背包，可使这些物品的耗费的费用总和不超过背包容量，且价值总和最大。

假设山洞里共有a,b,c,d ,e这5件宝物（不是5种宝物），它们的重量分别是2,2,6,5,4，
它们的价值分别是6,3,5,4,6，现在给你个承重为10的背包, 怎么装背包，可以才能带走最多的财富(每件宝物可重复选取)。

伪代码:
for i in [1, N]:
  for j in [W_i, V]:
    // j in [1, V] and j-W_i >= 0
    f[i, j] = max(f[i-1, j], f[i, j-W_i]+V_i)
    
发现关键在于max内部的f[i-1, j-W_i]+V_i变成了f[i, j-W_i]+V_i, 这是由于物品可以重复选取, 所以去掉i物品的重量后仍然可以处于f[i]的状态中, 从而
进行重复选取

一维空间优化
for i in [1, N]:
  for j in [W_i, V]:
    // j in [1, V] and j-W_i >= 0
    f[j] = max(f[j], f[j-W_i]+V_i)
    
发现相比于01背包问题, 关键就在于j的内循环此时是正序[W_i, V], 01背包时j为逆序的原因是因为进行一次i循环后, 一维数组中的值会有f[i-1, j]更新为
f[i, j]并进行覆盖, 逆序的时候可以保证f[j]在于前一次的f[i-1,?]进行比较, 但对于完全背包问题, f[j]是在与f[i, ?]进行比较, 所以需要一维数组中的
值进行覆盖更新, 所以正序进行覆盖更新






***************************** 第三讲 多重背包问题 ***************************************** 
*************************************************************************************** 
有 N 种物品和一个容量为 V 的背包。第 i 种物品最多有 Mi 件可用，每件耗费的空间是 Ci，价值是 Wi。求解将哪些物品装入背包
可使这些物品的耗费的空间总和不超过背包容量，且价值总和最大。  （因为 M_i 件意味着可以重复选取）

第 i 种物品有 Mi + 1 种策略：取 0 件，取 1 件……取 Mi 件, 令令 f[i, j]表示前 i 种物品恰放入一个容量为 j 的背包的最大价值
 f[i, j] = max(f[i-1, j - k * W_i] + k * v_i), k \in [0, M_i]

***************************** 第五讲 二维费用的背包问题 ***************************************** 
*************************************************************************************** 
