
***************************** 第一讲 01背包问题 ***************************************** 
*************************************************************************************** 
有N 件物品和一个容量为V 的背包。放入第i 件物品耗费的费用是Ci，得到的价值是Wi。求解将哪些物品装入背包可使价值总和
最大。

假设山洞里共有a,b,c,d ,e这5件宝物（不是5种宝物），它们的重量分别是2,2,6,5,4，
它们的价值分别是6,3,5,4,6，现在给你个承重为10的背包, 怎么装背包，可以才能带走最多的财富(每件宝物不可重复选取)。

i  name weight value | j: 1   2   3   4   5   6   7   8   9   10
1   a     4     6    |    0   0   0   6   6   6   6   6   6   6
2   b     5     4    |    0   0   0   6   6   6   6   6   10  10
3   c     6     5    |    0   0   0   6   6   6   6   6   10  11
4   d     2     3    |    0   3 	3   6 	6   9 	9  	9 	10 	11
5   e     2     6    |    0   6 	6   9 	9   12  12 	15 	15 	15

// ************************ 二维动态规划 ************************
// f[i, j]表示到第i个宝物为止, 使用j大小的背包所获得的财富
for i in [1, 5]:
  for j in [W_i, 10]:
    // j in [1, 10] and j-W_i >= 0
    f[i, j] = max(f[i-1, j], f[i-1, j-W_i]+V_i)
    
这里需要注意: w_i表示的是第i个物品, 对于编程时的第i个物品, 其索引事实上为i-1, 所以是j-W_{i-1}

f[1, 4]  = max(f[0, 4], f[0, 0]+V_1) = max(0, 0+6) = 6
f[1, 5]  = max(f[0, 5], f[0, 1]+V_1) = max(0, 0+6) = 6
f[1, 6]  = max(f[0, 6], f[0, 2]+V_1) = max(0, 0+6) = 6
f[1, 7]  = max(f[0, 7], f[0, 3]+V_1) = max(0, 0+6) = 6
f[1, 8]  = max(f[0, 8], f[0, 4]+V_1) = max(0, 0+6) = 6
f[1, 9]  = max(f[0, 9], f[0, 5]+V_1) = max(0, 0+6) = 6
f[1, 10] = max(f[0, 10], f[0, 6]+V_1) = max(0, 0+6) = 6

f[2, 5]  = max(f[1, 5], f[1, 0]+V_2) = max(6, 0+4) = 6
f[2, 6]  = max(f[1, 6], f[1, 1]+V_2) = max(6, 0+4) = 6
f[2, 7]  = max(f[1, 7], f[1, 2]+V_2) = max(6, 0+4) = 6
f[2, 8]  = max(f[1, 8], f[1, 3]+V_2) = max(6, 0+4) = 6
f[2, 9]  = max(f[1, 9], f[1, 4]+V_2) = max(6, 6+4) = 10
f[2, 10] = max(f[1, 10], f[1, 5]+V_2) = max(6, 6+4) = 10


f[3, 6]  = max(f[2, 6], f[2, 0]+V_3) = max(6, 0+5) = 6
f[3, 7]  = max(f[2, 7], f[2, 1]+V_3) = max(6, 0+5) = 6
f[3, 8]  = max(f[2, 8], f[2, 2]+V_3) = max(6, 0+5) = 6
f[3, 9]  = max(f[2, 9], f[2, 3]+V_3) = max(10, 0+5) = 6
f[3, 10] = max(f[2, 10], f[2, 4]+V_3) = max(10, 0+5) = 6 // 此时发现f[2, 4]并未进行计算,因此需要把f[2, 4]从f[1, 4]继承下来

伪代码修正如下:
for i in [1, 5]:
  for j in [1, 10]:
    if j-W_i >= 0:
      f[i, j] = max(f[i-1, j], f[i-1, j-W_i]+V_i)
    else:
      f[i, j] = f[i-1, j]
      
int dp(int num, int volume, vector<int> weight, vector<int> value) {
    if ((weight.size() != value.size()) || num <= 0 || volume <= 0) {
        return 0;
    }
    vector<vector<int>> dp(num+1, vector<int>(volume+1, 0));
    for (int i = 1; i <= num; ++i) {
        for (int j = 1; j <= volume; ++j) {
            if ((j - weight[i-1]) >= 0) {
                dp[i][j] = max(dp[i-1][j], dp[i-1][j-weight[i-1]] + value[i-1]);
            }
            else {
                dp[i][j] = dp[i-1][j];
            }
        }
    }
    cout << dp[num][volume] << endl;
    return dp[num][volume];
}
      
// ************************ 一维动态规划 ************************
   f[i, j] = max(f[i-1, j], f[i-1, j-W_i]+V_i) 
=> f[j] = max(f[j], f[j-W_i]+V_i)

若不对j的循环顺序进行更改:
for i in [1, 5]:
  for j in [1, 10]:
    f[j] = max(f[j], f[j-W_i]+V_i)
    
f[1, 4]  = max(f[0, 4], f[0, 0]+V_1) = max(0, 0+6) = 6
f[1, 5]  = max(f[0, 5], f[0, 1]+V_1) = max(0, 0+6) = 6
f[1, 6]  = max(f[0, 6], f[0, 2]+V_1) = max(0, 0+6) = 6
f[1, 7]  = max(f[0, 7], f[0, 3]+V_1) = max(0, 0+6) = 6
f[1, 8]  = max(f[0, 8], f[0, 4]+V_1) = max(0, 0+6) = 6
f[1, 9]  = max(f[0, 9], f[0, 5]+V_1) = max(0, 0+6) = 6
f[1, 10] = max(f[0, 10], f[0, 6]+V_1) = max(0, 0+6) = 6

若正向更新, 会发现f[8]其实要使用f[0, 4]但是f[4]已经提前被更新成f[1, 4]了, 无法使用i-1的数据

所以将j进行逆序处理
for i in [1, 5]:
  for j in [10, 1]:
    f[j] = max(f[j], f[j-W_i]+V_i)
    
f[1, 10] = max(f[0, 10], f[0, 6]+V_1) = max(0, 0+6) = 6
f[1, 9]  = max(f[0, 9], f[0, 5]+V_1) = max(0, 0+6) = 6
f[1, 8]  = max(f[0, 8], f[0, 4]+V_1) = max(0, 0+6) = 6
f[1, 7]  = max(f[0, 7], f[0, 3]+V_1) = max(0, 0+6) = 6
f[1, 6]  = max(f[0, 6], f[0, 2]+V_1) = max(0, 0+6) = 6
f[1, 5]  = max(f[0, 5], f[0, 1]+V_1) = max(0, 0+6) = 6
f[1, 4]  = max(f[0, 4], f[0, 0]+V_1) = max(0, 0+6) = 6

此时发现, f[8]先使用了f[0, 4]然后f[1, 4]才进行更新

// 初始化细节
// 若恰好装满背包: 则f[0] = 0, f[1]...f[10]应该为-inf
// 若可以不装满背包: 则f[0]~f[10]均为0
// 因为初始化表示了没有任何物品放置时, 数组的合法状态
// 若必须装满背包, 则只有容量为0的背包的合理value为0, 其余状态没有合法解, 属于未定义
// 若不必装满背包, 则任何容量的背包都有合法解0, 因为可以不选取任何物品

// 常数优化
for i in [1, N]:
  for j in [V, W_i]:
    f[j] = max(f[j], f[j-W_i]+V_i)
中的j循环可以从 j \in [V, W_i] 优化为 j \in [V, max(W_i, V-\sum_{k=i}^{N}W_k)],
\sum_{k=i}^{N}W_k 表示i到N的所有物品重量

------------------------------------------------------>
       (V-\sum<=C_i)          C_i      (V-\sum>C_i)
考虑到我们只需要矩阵的右下角的元素, 我们只需要考虑计算右下角的元素需要的最少dp数即可, 
对于i = N时的右下角元素f[V], 有如下等式成立
f[V] = max(f[V], f[V-W_N]+V_N), 需要使用f[V-W_N]元素
对于i = N-1层的f[V-W_N], 有
f[V-W_N] = max(f[V-W_N], f[V-W_N-W_N-1]+V_N),
依次递推可知, 对于第i层实际上需要计算的可以到达网络右下角的元素应该为V - W_N - W_n-1 - ... - W_i

因此, 对于第i层, 小于W_i由于背包容量不足不更新, 小于V - W_N - W_n-1 - ... - W_i由于无法到达右下角不需要更新, 取二者Max即可


                              
i  name weight value | j: 1   2   3   4   5   6   7   
                          0   0   0   0   0   0   0  
1   a     1     6    |    *   *   6   6   6   6   6   
2   b     1     4    |    *   *   *   10  10  10  10   
3   c     1     5    |    *   *   *   *   15  15  15   
4   d     1     3    |    *   * 	*   * 	*   18 	18  	
5   e     1     6    |    *   * 	*   * 	*   *   12 	

for i in [1, N]:
  for j in [V, max(W_i, V-\sum_{k=i}^{N}W_k)]:
    f[j] = max(f[j], f[j-W_i]+V_i)

i = 1
max(W_i, V-\sum_{k=i}^{N}W_k)) = max(1, 7-4) = 3
f[7] = max(f[7], f[6]+V_1) = max(0, 0+6) = 6
f[6] = max(f[6], f[5]+V_1) = max(0, 0+6) = 6
f[5] = max(f[5], f[4]+V_1) = max(0, 0+6) = 6
f[4] = max(f[4], f[3]+V_1) = max(0, 0+6) = 6
f[3] = max(f[3], f[2]+V_1) = max(0, 0+6) = 6
f[1]在正常算法中应该更新, 此时省去

i = 2
max(W_i, V-\sum_{k=i}^{N}W_k)) = max(1, 7-3) = 4
f[7] = max(f[7], f[6]+V_2) = max(6, 6+4) = 10
f[6] = max(f[6], f[5]+V_2) = max(6, 6+4) = 10
f[5] = max(f[5], f[4]+V_2) = max(6, 6+4) = 10
f[4] = max(f[4], f[3]+V_2) = max(6, 6+4) = 10
f[3], f[2], f[1]在正常算法中应该更新, 此时省去


***************************** 第二讲 完全背包问题 ***************************************** 
*************************************************************************************** 
有N 种物品和一个容量为V 的背包，每种物品都有无限件可用。放入第i 种物品的费用是Ci，价值是Wi。求解：将哪些物品
装入背包，可使这些物品的耗费的费用总和不超过背包容量，且价值总和最大。

假设山洞里共有a,b,c,d ,e这5件宝物（不是5种宝物），它们的重量分别是2,2,6,5,4，
它们的价值分别是6,3,5,4,6，现在给你个承重为10的背包, 怎么装背包，可以才能带走最多的财富(每件宝物可重复选取)。

伪代码:
for i in [1, N]:
  for j in [W_i, V]:
    // j in [1, V] and j-W_i >= 0
    f[i, j] = max(f[i-1, j], f[i, j-W_i]+V_i)
    
发现关键在于max内部的f[i-1, j-W_i]+V_i变成了f[i, j-W_i]+V_i, 这是由于物品可以重复选取, 所以去掉i物品的重量后仍然可以处于f[i]的状态中, 从而
进行重复选取

一维空间优化
for i in [1, N]:
  for j in [W_i, V]:
    // j in [1, V] and j-W_i >= 0
    f[j] = max(f[j], f[j-W_i]+V_i)
    
发现相比于01背包问题, 关键就在于j的内循环此时是正序[W_i, V], 01背包时j为逆序的原因是因为进行一次i循环后, 一维数组中的值会有f[i-1, j]更新为
f[i, j]并进行覆盖, 逆序的时候可以保证f[j]在于前一次的f[i-1,?]进行比较, 但对于完全背包问题, f[j]是在与f[i, ?]进行比较, 所以需要一维数组中的
值进行覆盖更新, 所以正序进行覆盖更新






***************************** 第三讲 多重背包问题 ***************************************** 
*************************************************************************************** 
有 N 种物品和一个容量为 V 的背包。第 i 种物品最多有 Mi 件可用，每件耗费的空间是 Ci，价值是 Wi。求解将哪些物品装入背包
可使这些物品的耗费的空间总和不超过背包容量，且价值总和最大。  （因为 M_i 件意味着可以重复选取）

第 i 种物品有 Mi + 1 种策略：取 0 件，取 1 件……取 Mi 件, 令令 f[i, j]表示前 i 种物品恰放入一个容量为 j 的背包的最大价值

 f[i, j] = max(f[i-1, j - k * W_i] + k * v_i), k \in [0, current_M_i], 注意此处为i-1, 认为一次性将该种物品取够件数之后换下一种
 
 	//假设山洞里共有a, b, c, d, e这5件宝物（不是5种宝物），它们的重量分别是2, 2, 6, 5, 4，
	//	它们的价值分别是6, 3, 5, 4, 6，现在给你个承重为10的背包, 怎么装背包，可以才能带走最多的财富(每件宝物不可重复选取)
  // 不可重复选取就是times都是1

	vector<vector<int>> dp(6, vector<int>(11, 0));
	vector<int> weight = { 2, 2, 6, 5, 4 };
	vector<int> value = { 6, 3, 5, 4, 6 };
	vector<int> times = { 1, 1, 1, 1, 1 };
	for (int i = 1; i <= 5; ++i){
		for (int j = 1; j <= 10; ++j) {
			for (int k = 0; k <= times[i - 1]; ++k) {
				if (j >= k * weight[i - 1]) {
					dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - k * weight[i - 1]] + k * value[i - 1]);
				}
			}
		}
	}
	cout << dp[5][10];

***************************** 第四讲 混合三种背包问题 ***************************************** 
*************************************************************************************** 
故如果只有两类物品：一类物品只能取一次，另一类物品可以取无限次，还有一类可以取k次， 那么只需在对每个物品应用转移方程时，根据物品的
类别选用不同的递归方法即可：
for i in [1, N]:
  if 第i件物品属于01背包：
    for j in [1, V]:
      f[i, j] = max(f[i-1, j], f[i-1, j - W_i] + V_i)
  else if 第i件物品属于完全背包：
    for j in [1, V]:
      f[i, j] = max(f[i-1, j], f[i, j - W_i] + V_i)
  else 第i件物品属于多重背包
      for j in [1, V]:
        f[i, j] = max(f[i, j - k * W_i] + V_i), k \in [0, M_i]
	
***************************** 第五讲 二维费用的背包问题 ***************************************** 
*************************************************************************************** 
对于每件物品，具有两种不同的费用，选择这件物品必须同时付出这两种费用。对于每种费用都有一个可付出的最大值（背包容量）。问怎样
选择物品可以得到最大的价值。

设第 i 件物品所需的两种费用分别为 Ci 和 Di。两种费用可付出的最大值（也即两种背包容量）分别为 V 和 U。物品的价值为 Wi。
设 f[i, v, u] 表示前 i 件物品付出两种费用分别为 v 和 u 时可获得的最大价值
for i in [1, N]:
  for j in [1, V]:
    for k in [1, U]:
      f[i, v, u] = max(f[i-1, v, u], f[i-1, v-C_i, u-D_i]+V_i)

此时也会产生变化， 物品只能选取一次时采用01背包更新方法， 如上公式， 物品能够选取多次时使用完全背包更新方法，物品选取固定次数时，使用多重背包更新
方法，混合多重背包时使用if判断

注: 当每种物品引入了选取次数的限定时，其实也可以理解为一种限定的费用




***************************** 2019 阿里巴巴笔试题 ***************************************** 
*************************************************************************************** 
小明在双十一晚会上抽奖赢得了一次了一次天猫超市免单机会，享受在一个包裹内最大体积V，最大重量M内免单。假设商品i，体积Vi，重量Mi，库存Si，价格Pi。
目前，天猫超市的商品分为生鲜水产(1)、食品酒类(2)、美妆个护(3)、居家生活(4)四大类，其中生鲜水产不与美妆个护同包裹。请你帮助小明在购物车里添置商
品使得总价值最大

https://blog.csdn.net/The_Wind_Rises/article/details/89258048


商品总类n，包裹限定总体积v，包裹限定总重量m（接下来会有n行）
商品1体积，商品1重量，商品1库存，商品1价格，商品1类型
商品2体积，商品2重量，商品2库存，商品2价格，商品2类型
商品3体积，商品3重量，商品3库存，商品3价格，商品3类型

int N = 3;
int volume = 40;
int weight = 30;
vector<vector<int> > product = { {10, 10, 10, 10, 1}, {13, 10, 12, 11, 3}, {3, 4, 6, 5, 3} };
// 体积, 重量， 库存, 价格
vector<vector<vector<int>>> dp(3 + 1, vector<vector<int>>(volume + 1, vector<int>(weight + 1, 0)));
for (int i = 1; i <= N; ++i) {
	for (int j = 1; j <= volume; ++j) {
		for (int k = 1; k <= weight; ++k) {
			for (int p = 0; p <= product[i - 1][2]; ++p) {
				if (j >= p * product[i - 1][0] && k >= p * product[i - 1][1]) {
					dp[i][j][k] = max(dp[i - 1][j][k],
						dp[i - 1][j - p * product[i - 1][0]][k - p * product[i - 1][1]] + p * product[i - 1][3]);
				}
			}

		}
	}
}
cout << dp[N][volume][weight];
